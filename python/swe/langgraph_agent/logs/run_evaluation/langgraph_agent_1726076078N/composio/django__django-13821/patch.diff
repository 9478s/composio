diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py
index ab4ea704..03d58a2b 100644
--- a/django/db/backends/sqlite3/base.py
+++ b/django/db/backends/sqlite3/base.py
@@ -84,6 +84,116 @@ class DatabaseWrapper(BaseDatabaseWrapper):
     # SQLite doesn't actually support most of these types, but it "does the right
     # thing" given more verbose field definitions, so leave them as is so that
     # schema inspection is more useful.
+    data_types = {
+        'AutoField': 'integer',
+        'BigAutoField': 'integer',
+        'BinaryField': 'BLOB',
+        'BooleanField': 'bool',
+        'CharField': 'varchar(%(max_length)s)',
+        'DateField': 'date',
+        'DateTimeField': 'datetime',
+        'DecimalField': 'decimal',
+        'DurationField': 'bigint',
+        'FileField': 'varchar(%(max_length)s)',
+        'FilePathField': 'varchar(%(max_length)s)',
+        'FloatField': 'real',
+        'IntegerField': 'integer',
+        'BigIntegerField': 'bigint',
+        'IPAddressField': 'char(15)',
+        'GenericIPAddressField': 'char(39)',
+        'JSONField': 'text',
+        'OneToOneField': 'integer',
+        'PositiveBigIntegerField': 'bigint',
+        'PositiveIntegerField': 'integer',
+        'PositiveSmallIntegerField': 'smallint',
+        'SlugField': 'varchar(%(max_length)s)',
+        'SmallAutoField': 'integer',
+        'SmallIntegerField': 'smallint',
+        'TextField': 'text',
+        'TimeField': 'time',
+        'UUIDField': 'char(32)',
+    }
+    data_type_check_constraints = {
+        'PositiveBigIntegerField': '"%(column)s" >= 0',
+        'PositiveIntegerField': '"%(column)s" >= 0',
+        'PositiveSmallIntegerField': '"%(column)s" >= 0',
+    }
+    data_types_suffix = {
+        'AutoField': 'AUTOINCREMENT',
+        'BigAutoField': 'AUTOINCREMENT',
+        'SmallAutoField': 'AUTOINCREMENT',
+    }
+    operators = {
+        'exact': '= %s',
+        'iexact': "LIKE %s ESCAPE '\\'",
+        'contains': "LIKE %s ESCAPE '\\'",
+        'icontains': "LIKE %s ESCAPE '\\'",
+        'regex': 'REGEXP %s',
+        'iregex': "REGEXP '(?i)' || %s",
+        'gt': '> %s',
+        'gte': '>= %s',
+        'lt': '< %s',
+        'lte': '<= %s',
+        'startswith': "LIKE %s ESCAPE '\\'",
+        'endswith': "LIKE %s ESCAPE '\\'",
+        'istartswith': "LIKE %s ESCAPE '\\'",
+        'iendswith': "LIKE %s ESCAPE '\\'",
+    }
+
+    # The patterns below are used to generate SQL pattern lookup clauses when
+    # the right-hand side of the lookup isn't a raw string (it might be an expression
+    # or the result of a bilateral transformation).
+    # In those cases, special characters for LIKE operators (e.g. \, *, _) should be
+    # escaped on database side.
+    #
+    # Note: we use str.format() here for readability as '%' is used as a wildcard for
+    # the LIKE operator.
+    pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
+    pattern_ops = {
+        'contains': r"LIKE '%%' || {} || '%%' ESCAPE '\'",
+        'icontains': r"LIKE '%%' || UPPER({}) || '%%' ESCAPE '\'",
+        'startswith': r"LIKE {} || '%%' ESCAPE '\'",
+        'istartswith': r"LIKE UPPER({}) || '%%' ESCAPE '\'",
+        'endswith': r"LIKE '%%' || {} ESCAPE '\'",
+        'iendswith': r"LIKE '%%' || UPPER({}) ESCAPE '\'",
+    }
+
+    Database = Database
+    SchemaEditorClass = DatabaseSchemaEditor
+    # Classes instantiated in __init__().
+    client_class = DatabaseClient
+    creation_class = DatabaseCreation
+    features_class = DatabaseFeatures
+    introspection_class = DatabaseIntrospection
+    ops_class = DatabaseOperations
+
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.check_sqlite_version()
+
+    def check_sqlite_version(self):
+        if Database.sqlite_version_info < (3, 9, 0):
+            raise ImproperlyConfigured(
+                f"SQLite {'.'.join(map(str, Database.sqlite_version_info))} is not supported. "
+                "Please upgrade to SQLite 3.9.0 or higher."
+            )
+
+    def get_new_connection(self, conn_params):
+        conn = super().get_new_connection(conn_params)
+        with conn:
+            cur = conn.cursor()
+            cur.execute('SELECT sqlite_version()')
+            version = cur.fetchone()[0]
+            if tuple(map(int, version.split('.'))) < (3, 9, 0):
+                raise ImproperlyConfigured(
+                    f"SQLite {version} is not supported. "
+                    "Please upgrade to SQLite 3.9.0 or higher."
+                )
+        return conn
+    # vendor and display_name are already defined at the beginning of the class
+    # SQLite doesn't actually support most of these types, but it "does the right
+    # thing" given more verbose field definitions, so leave them as is so that
+    # schema inspection is more useful.
     data_types = {
         'AutoField': 'integer',
         'BigAutoField': 'integer',
diff --git a/docs/ref/databases.txt b/docs/ref/databases.txt
index 809ee68d..8fc9e896 100644
--- a/docs/ref/databases.txt
+++ b/docs/ref/databases.txt
@@ -679,7 +679,7 @@ appropriate typecasting.
 SQLite notes
 ============
 
-Django supports SQLite 3.8.3 and later.
+Django supports SQLite 3.9.0 and later.
 
 SQLite_ provides an excellent development alternative for applications that
 are predominantly read-only or require a smaller installation footprint. As
