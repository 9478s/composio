diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py
index e0c42c5..94f6f23 100644
--- a/lib/matplotlib/colors.py
+++ b/lib/matplotlib/colors.py
@@ -1540,6 +1540,78 @@ class FuncNorm(Normalize):
 
 
 @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive="mask"))
+class LogNorm(Normalize):
+    def __init__(self, vmin=None, vmax=None, clip=False):
+        super().__init__(vmin, vmax, clip)
+
+    def __call__(self, value, clip=None):
+        import numpy as np
+        import logging
+
+        logging.basicConfig(level=logging.DEBUG)
+        logger = logging.getLogger(__name__)
+
+        result, is_scalar = self.process_value(value)
+        self.autoscale_None(result)
+        
+        logger.debug(f"Initial vmin: {self.vmin}, vmax: {self.vmax}")
+
+        # Handle masked arrays
+        if np.ma.is_masked(result):
+            mask = result.mask
+            result = result.filled(self.vmin)  # Fill masked values with vmin
+        else:
+            mask = None
+        
+        # Ensure vmin and vmax are positive
+        self.vmin = max(self.vmin, np.finfo(float).tiny)
+        self.vmax = max(self.vmax, self.vmin * (1 + np.finfo(float).eps))
+        
+        logger.debug(f"Adjusted vmin: {self.vmin}, vmax: {self.vmax}")
+
+        # Log transform
+        result = np.log10(np.maximum(result, self.vmin))
+        t_vmin, t_vmax = np.log10([self.vmin, self.vmax])
+        
+        logger.debug(f"Transformed vmin: {t_vmin}, vmax: {t_vmax}")
+
+        if not np.isfinite([t_vmin, t_vmax]).all():
+            logger.warning("Non-finite values detected after log transform")
+            t_vmin = np.clip(t_vmin, np.log10(np.finfo(float).tiny), np.log10(np.finfo(float).max))
+            t_vmax = np.clip(t_vmax, t_vmin + np.finfo(float).eps, np.log10(np.finfo(float).max))
+            logger.debug(f"Clipped vmin: {t_vmin}, vmax: {t_vmax}")
+
+        # Normalize
+        if t_vmin == t_vmax:
+            result.fill(0)
+        else:
+            if clip:
+                mask = np.ma.getmask(result)
+                result = np.ma.array(np.clip(result.filled(t_vmax), t_vmin, t_vmax),
+                                     mask=mask)
+            # ma division is very slow; we can take a shortcut
+            resdat = result.data
+            resdat -= t_vmin
+            resdat /= (t_vmax - t_vmin)
+            result = np.ma.array(resdat, mask=result.mask, copy=False)
+
+        if is_scalar:
+            result = result[0]
+        
+        logger.debug(f"Final result: {result}")
+        return result
+
+    def autoscale_None(self, A):
+        super().autoscale_None(A)
+        if self.vmin is not None and self.vmax is not None:
+            self.vmin = max(self.vmin, np.finfo(float).tiny)
+            self.vmax = max(self.vmax, self.vmin * (1 + np.finfo(float).eps))
+
+    def inverse(self, value):
+        if not self.scaled():
+            raise ValueError("Not invertible until scaled")
+        vmin, vmax = self.vmin, self.vmax
+        return vmin * np.power(vmax/vmin, value)
 class LogNorm(Normalize):
     """Normalize a given value to the 0-1 range on a log scale."""
 
