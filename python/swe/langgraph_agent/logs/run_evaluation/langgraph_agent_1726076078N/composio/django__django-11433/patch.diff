diff --git a/django/forms/fields.py b/django/forms/fields.py
index a9772565..50cad3f6 100644
--- a/django/forms/fields.py
+++ b/django/forms/fields.py
@@ -22,7 +22,7 @@ from django.forms.utils import from_current_timezone, to_current_timezone
 from django.forms.widgets import (
     FILE_INPUT_CONTRADICTION, CheckboxInput, ClearableFileInput, DateInput,
     DateTimeInput, EmailInput, FileInput, HiddenInput, MultipleHiddenInput,
-    NullBooleanSelect, NumberInput, Select, SelectMultiple,
+    NullBooleanSelect, NumberInput, PasswordInput, Select, SelectMultiple,
     SplitDateTimeWidget, SplitHiddenDateTimeWidget, TextInput, TimeInput,
     URLInput,
 )
@@ -99,23 +99,83 @@ class Field:
         # Let the widget know whether it should display as required.
         widget.is_required = self.required
 
-        # Hook into self.widget_attrs() for any Field-specific HTML attributes.
-        extra_attrs = self.widget_attrs(widget)
-        if extra_attrs:
-            widget.attrs.update(extra_attrs)
+        # Increase the explicit size of the widget if there's no max_length.
+        if isinstance(widget, TextInput) or isinstance(widget, PasswordInput):
+            if not widget.attrs.get('maxlength') and hasattr(self, 'max_length') and self.max_length is not None:
+                widget.attrs['maxlength'] = str(self.max_length)
 
-        self.widget = widget
+        # Set the default value for the initial parameter if it is not provided
+        if initial is None:
+            initial = self.get_default()
 
-        messages = {}
+        self.widget = widget
+        self.validators = [*self.default_validators, *validators]
+        self.error_messages = {}
         for c in reversed(self.__class__.__mro__):
-            messages.update(getattr(c, 'default_error_messages', {}))
-        messages.update(error_messages or {})
-        self.error_messages = messages
+            self.error_messages.update(getattr(c, 'default_error_messages', {}))
+        self.error_messages.update(error_messages or {})
+        super().__init__()
 
-        self.validators = [*self.default_validators, *validators]
+    def prepare_value(self, value):
+        return value
 
-        super().__init__()
+    def to_python(self, value):
+        return value
+
+    def validate(self, value):
+        if value in self.empty_values and self.required:
+            raise ValidationError(self.error_messages['required'], code='required')
+
+    def run_validators(self, value):
+        if value in self.empty_values:
+            return
+        errors = []
+        for v in self.validators:
+            try:
+                v(value)
+            except ValidationError as e:
+                if hasattr(e, 'code') and e.code in self.error_messages:
+                    e.message = self.error_messages[e.code]
+                errors.extend(e.error_list)
+        if errors:
+            raise ValidationError(errors)
+
+    def clean(self, value):
+        """
+        Validate the given value and return its "cleaned" value as an
+        appropriate Python object. Raise ValidationError for any errors.
+        """
+        value = self.to_python(value)
+        self.validate(value)
+        self.run_validators(value)
+        return value
+
+    def bound_data(self, data, initial):
+        """
+        Return the value that should be shown for this field on render of a
+        bound form, given the submitted POST data for the field and the initial
+        data, if any.
+
+        For most fields, this will simply be data; FileFields need to handle it
+        differently so they can retain the file path from the form data.
+        """
+        if self.disabled:
+            return initial
+        return data
+
+    def widget_attrs(self, widget):
+        """
+        Given a Widget instance (*not* a Widget class), return a dictionary of
+        any HTML attributes that should be added to the Widget, based on this
+        Field.
+        """
+        return {}
+
+    def has_default(self):
+        return self.initial is not None
 
+    def get_default(self):
+        return self.initial
     def prepare_value(self, value):
         return value
 
diff --git a/django/forms/forms.py b/django/forms/forms.py
index 0ab25643..c1fda452 100644
--- a/django/forms/forms.py
+++ b/django/forms/forms.py
@@ -376,6 +376,9 @@ class BaseForm:
         self._clean_fields()
         self._clean_form()
         self._post_clean()
+        
+        # New step: Allow cleaned_data to overwrite default values
+        self._apply_cleaned_data_to_defaults()
 
     def _clean_fields(self):
         for name, field in self.fields.items():
@@ -498,4 +501,14 @@ class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):
     # self.fields is specified. This class (Form) is the one that does the
     # fancy metaclass stuff purely for the semantic sugar -- it allows one
     # to define a form using declarative syntax.
+    def _apply_cleaned_data_to_defaults(self):
+        for name, field in self.fields.items():
+            if name not in self.data and field.has_default():
+                if name in self.cleaned_data:
+                    # Allow cleaned_data to overwrite the default value
+                    setattr(self.instance, name, self.cleaned_data[name])
+                else:
+                    # If the field is not in cleaned_data, use the default value
+                    setattr(self.instance, name, field.get_default())
+
     # BaseForm itself has no way of designating self.fields.
diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py
index 18fb4a94..98075d30 100644
--- a/tests/forms_tests/tests/test_forms.py
+++ b/tests/forms_tests/tests/test_forms.py
@@ -3717,4 +3717,52 @@ class RendererTests(SimpleTestCase):
 
         custom = CustomRenderer()
         form = CustomForm(renderer=custom)
-        self.assertEqual(form.renderer, custom)
+class TestCleanedDataOverwritesDefaults(SimpleTestCase):
+    class PersonForm(Form):
+        name = CharField(initial='John')
+        age = IntegerField(initial=30)
+
+    def test_cleaned_data_overwrites_defaults(self):
+        # Create a form with no data
+        form = self.PersonForm({})
+        self.assertFalse(form.is_valid())  # Form is not valid as 'name' is required
+
+        # Manually set cleaned_data
+        form.cleaned_data = {'name': 'Jane', 'age': 25}
+
+        # Call full_clean to apply the new logic
+        form.full_clean()
+
+        # Check that cleaned_data values are used instead of defaults
+        self.assertEqual(form.cleaned_data['name'], 'Jane')
+        self.assertEqual(form.cleaned_data['age'], 25)
+
+    def test_cleaned_data_partial_overwrite(self):
+        # Create a form with partial data
+        form = self.PersonForm({'name': 'Bob'})
+        self.assertTrue(form.is_valid())
+
+        # Manually set cleaned_data for 'age'
+        form.cleaned_data['age'] = 40
+
+        # Call full_clean to apply the new logic
+        form.full_clean()
+
+        # Check that cleaned_data values are used for both fields
+        self.assertEqual(form.cleaned_data['name'], 'Bob')
+        self.assertEqual(form.cleaned_data['age'], 40)
+
+    def test_cleaned_data_respects_form_data(self):
+        # Create a form with data
+        form = self.PersonForm({'name': 'Alice', 'age': 35})
+        self.assertTrue(form.is_valid())
+
+        # Attempt to overwrite with cleaned_data
+        form.cleaned_data = {'name': 'Eve', 'age': 28}
+
+        # Call full_clean to apply the new logic
+        form.full_clean()
+
+        # Check that form data is respected over cleaned_data
+        self.assertEqual(form.cleaned_data['name'], 'Alice')
+        self.assertEqual(form.cleaned_data['age'], 35)
