diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py
index b98abfa..1dc9526 100644
--- a/astropy/units/quantity.py
+++ b/astropy/units/quantity.py
@@ -642,6 +642,12 @@ class Quantity(np.ndarray):
         # and the unit of the result (or tuple of units for nout > 1).
         converters, unit = converters_and_unit(function, method, *inputs)
 
+        # If converters_and_unit returned (None, None), it means the operation
+        # is not supported or the units are incompatible. In this case, we
+        # return NotImplemented to allow other operands to handle the operation.
+        if converters is None and unit is None:
+            return NotImplemented
+
         out = kwargs.get("out", None)
         # Avoid loop back by turning any Quantity output into array views.
         if out is not None:
diff --git a/astropy/units/quantity_helper/converters.py b/astropy/units/quantity_helper/converters.py
index 47b40c2..dd2d32e 100644
--- a/astropy/units/quantity_helper/converters.py
+++ b/astropy/units/quantity_helper/converters.py
@@ -156,16 +156,13 @@ def converters_and_unit(function, method, *args):
     *args :  `~astropy.units.Quantity` or ndarray subclass
         Input arguments to the function
 
-    Raises
-    ------
-    TypeError : when the specified function cannot be used with Quantities
-        (e.g., np.logical_or), or when the routine does not know how to handle
-        the specified function (in which case an issue should be raised on
-        https://github.com/astropy/astropy).
-    UnitTypeError : when the conversion to the required (or consistent) units
-        is not possible.
+    Returns
+    -------
+    converters : tuple
+        Tuple of converter functions for each input argument
+    result_unit : `~astropy.units.Unit` or None
+        Unit of the ufunc result
     """
-
     # Check whether we support this ufunc, by getting the helper function
     # (defined in helpers) which returns a list of function(s) that convert the
     # input(s) to the unit required for the ufunc, as well as the unit the
@@ -197,20 +194,13 @@ def converters_and_unit(function, method, *args):
                     if can_have_arbitrary_unit(args[i]):
                         converters[i] = None
                     else:
-                        raise UnitConversionError(
-                            f"Can only apply '{function.__name__}' function to "
-                            "dimensionless quantities when other argument is not "
-                            "a quantity (unless the latter is all zero/infinity/nan)."
-                        )
+                        # Instead of raising UnitConversionError, return a special value
+                        return (None, None)
             except TypeError:
                 # _can_have_arbitrary_unit failed: arg could not be compared
                 # with zero or checked to be finite. Then, ufunc will fail too.
-                raise TypeError(
-                    "Unsupported operand type(s) for ufunc {}: '{}'".format(
-                        function.__name__,
-                        ",".join([arg.__class__.__name__ for arg in args]),
-                    )
-                )
+                # Instead of raising TypeError, return a special value
+                return (None, None)
 
         # In the case of np.power and np.float_power, the unit itself needs to
         # be modified by an amount that depends on one of the input values,
@@ -233,7 +223,8 @@ def converters_and_unit(function, method, *args):
                     try:
                         converters[0] = units[0]._get_converter(dimensionless_unscaled)
                     except UnitConversionError:
-                        raise exc
+                        # Instead of raising the exception, return a special value
+                        return (None, None)
                     else:
                         result_unit = dimensionless_unscaled
 
@@ -260,32 +251,24 @@ def converters_and_unit(function, method, *args):
 
         else:
             if method in {"reduce", "accumulate", "reduceat", "outer"} and nin != 2:
-                raise ValueError(f"{method} only supported for binary functions")
+                # Instead of raising ValueError, return a special value
+                return (None, None)
 
-            raise TypeError(
-                f"Unexpected ufunc method {method}.  If this should work, please "
-                "raise an issue on https://github.com/astropy/astropy"
-            )
+            # Instead of raising TypeError, return a special value
+            return (None, None)
 
         # for all but __call__ method, scaling is not allowed
         if unit is not None and result_unit is None:
-            raise TypeError(
-                f"Cannot use '{method}' method on ufunc {function.__name__} with a "
-                "Quantity instance as the result is not a Quantity."
-            )
+            # Instead of raising TypeError, return a special value
+            return (None, None)
 
         if converters[0] is not None or (
             unit is not None
             and unit is not result_unit
             and (not result_unit.is_equivalent(unit) or result_unit.to(unit) != 1.0)
         ):
-            # NOTE: this cannot be the more logical UnitTypeError, since
-            # then things like np.cumprod will not longer fail (they check
-            # for TypeError).
-            raise UnitsError(
-                f"Cannot use '{method}' method on ufunc {function.__name__} with a "
-                "Quantity instance as it would change the unit."
-            )
+            # Instead of raising UnitsError, return a special value
+            return (None, None)
 
     return converters, result_unit
 
diff --git a/astropy/units/tests/test_units.py b/astropy/units/tests/test_units.py
index 27b0cff..c8c3c6e 100644
--- a/astropy/units/tests/test_units.py
+++ b/astropy/units/tests/test_units.py
@@ -916,3 +916,85 @@ def test_si_prefixes(name, symbol, multiplying_factor):
     value_ratio = base.value / quantity_from_symbol.value
 
     assert u.isclose(value_ratio, multiplying_factor)
+
+def test_quantity_array_ufunc_with_incompatible_units():
+    """Test that Quantity.__array_ufunc__ returns NotImplemented for incompatible units."""
+    a = 1 * u.m
+    b = 1 * u.s
+    
+    # Test addition
+    result = np.add(a, b)
+    assert result is NotImplemented
+    
+    # Test subtraction
+    result = np.subtract(a, b)
+    assert result is NotImplemented
+    
+    # Test multiplication (should not return NotImplemented)
+    result = np.multiply(a, b)
+    assert isinstance(result, u.Quantity)
+    assert result.unit == u.m * u.s
+    
+    # Test division (should not return NotImplemented)
+    result = np.divide(a, b)
+    assert isinstance(result, u.Quantity)
+    assert result.unit == u.m / u.s
+
+def test_quantity_array_ufunc_with_compatible_units():
+    """Test that Quantity.__array_ufunc__ works correctly with compatible units."""
+    a = 1 * u.m
+    b = 100 * u.cm
+    
+    # Test addition
+    result = np.add(a, b)
+    assert isinstance(result, u.Quantity)
+    assert result.unit == u.m
+    assert_allclose(result.value, 2)
+    
+    # Test subtraction
+    result = np.subtract(a, b)
+    assert isinstance(result, u.Quantity)
+    assert result.unit == u.m
+    assert_allclose(result.value, 0)
+
+def test_quantity_array_ufunc_with_dimensionless():
+    """Test that Quantity.__array_ufunc__ works correctly with dimensionless quantities."""
+    a = 1 * u.m
+    b = 2 * u.dimensionless_unscaled
+    
+    # Test multiplication
+    result = np.multiply(a, b)
+    assert isinstance(result, u.Quantity)
+    assert result.unit == u.m
+    assert_allclose(result.value, 2)
+    
+    # Test division
+    result = np.divide(a, b)
+    assert isinstance(result, u.Quantity)
+    assert result.unit == u.m
+    assert_allclose(result.value, 0.5)
+
+def test_quantity_array_ufunc_with_non_quantity():
+    """Test that Quantity.__array_ufunc__ works correctly with non-Quantity objects."""
+    a = 1 * u.m
+    b = 2  # Regular Python scalar
+    
+    # Test multiplication
+    result = np.multiply(a, b)
+    assert isinstance(result, u.Quantity)
+    assert result.unit == u.m
+    assert_allclose(result.value, 2)
+    
+    # Test division
+    result = np.divide(a, b)
+    assert isinstance(result, u.Quantity)
+    assert result.unit == u.m
+    assert_allclose(result.value, 0.5)
+
+    # Test addition (should return NotImplemented)
+    result = np.add(a, b)
+    assert result is NotImplemented
+
+    # Test subtraction (should return NotImplemented)
+    result = np.subtract(a, b)
+    assert result is NotImplemented
