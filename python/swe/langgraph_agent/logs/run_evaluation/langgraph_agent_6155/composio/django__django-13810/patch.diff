diff --git a/django/core/handlers/base.py b/django/core/handlers/base.py
index 8e8c3da0..8d10a77f 100644
--- a/django/core/handlers/base.py
+++ b/django/core/handlers/base.py
@@ -49,6 +49,9 @@ class BaseHandler:
                 middleware_is_async = False
             else:
                 middleware_is_async = middleware_can_async
+            # Store the current state of handler and handler_is_async
+            previous_handler = handler
+            previous_handler_is_async = handler_is_async
             try:
                 # Adapt handler, if needed.
                 handler = self.adapt_method_mode(
@@ -57,6 +60,9 @@ class BaseHandler:
                 )
                 mw_instance = middleware(handler)
             except MiddlewareNotUsed as exc:
+                # Reset handler and handler_is_async to their previous state
+                handler = previous_handler
+                handler_is_async = previous_handler_is_async
                 if settings.DEBUG:
                     if str(exc):
                         logger.debug('MiddlewareNotUsed(%r): %s', middleware_path, exc)
diff --git a/docs/releases/3.2.txt b/docs/releases/3.2.txt
index 8cd77ffa..dabb38ba 100644
--- a/docs/releases/3.2.txt
+++ b/docs/releases/3.2.txt
@@ -97,7 +97,21 @@ if you do not have an explicit setting for :setting:`DEFAULT_AUTO_FIELD`.
 
 ``pymemcache`` support
 ----------------------
+Middleware behavior in ASGI applications
+----------------------------------------
 
+Fixed an issue where unused middleware in ASGI applications could affect the
+handler chain, potentially causing unexpected behavior. Now, when a middleware
+raises a ``MiddlewareNotUsed`` exception, the handler and its asynchronous
+state are properly reset to their previous values.
+
+Additionally, the documentation has been updated to clarify that when running
+Django as an ASGI application, all middleware in the chain should be capable
+of handling asynchronous requests, even if they are marked as ``sync_capable``.
+This is because the entire middleware chain may be executed in an asynchronous
+context.
+
+``pymemcache`` support
 The new ``django.core.cache.backends.memcached.PyMemcacheCache`` cache backend
 allows using the pymemcache_ library for memcached. ``pymemcache`` 3.4.0 or
 higher is required. For more details, see the :doc:`documentation on caching in
diff --git a/docs/topics/http/middleware.txt b/docs/topics/http/middleware.txt
index 1626d169..844929a2 100644
--- a/docs/topics/http/middleware.txt
+++ b/docs/topics/http/middleware.txt
@@ -75,6 +75,16 @@ Middleware can either support only synchronous Python (the default), only
 asynchronous Python, or both. See :ref:`async-middleware` for details of how to
 advertise what you support, and know what kind of request you are getting.
 
+.. note::
+   When running Django as an ASGI application, it's important to note that
+   all middleware in the chain should be capable of handling asynchronous
+   requests, even if they are marked as `sync_capable`. This is because the
+   entire middleware chain may be executed in an asynchronous context. If a
+   middleware is not async-capable and is used in an ASGI context, it may
+   lead to unexpected behavior or errors.
+
+Middleware can live anywhere on your Python path.
+
 Middleware can live anywhere on your Python path.
 
 ``__init__(get_response)``
diff --git a/tests/auth_tests/test_middleware.py b/tests/auth_tests/test_middleware.py
index b6151acb..a0067a59 100644
--- a/tests/auth_tests/test_middleware.py
+++ b/tests/auth_tests/test_middleware.py
@@ -59,3 +59,63 @@ class TestAuthenticationMiddleware(TestCase):
         )
         with self.assertRaisesMessage(AssertionError, msg):
             self.middleware(HttpRequest())
+
+class TestMiddlewareNotUsedASGI(TestCase):
+    @classmethod
+    def setUpTestData(cls):
+        cls.user = User.objects.create_user('test_user', 'test@example.com', 'test_password')
+
+    def setUp(self):
+        self.client.force_login(self.user)
+        self.request = HttpRequest()
+        self.request.session = self.client.session
+
+    async def test_middleware_not_used_asgi(self):
+        from django.core.handlers.asgi import ASGIHandler
+        from django.core.exceptions import MiddlewareNotUsed
+
+        class UnusedMiddleware:
+            def __init__(self, get_response):
+                raise MiddlewareNotUsed()
+
+        class TestMiddleware:
+            def __init__(self, get_response):
+                self.get_response = get_response
+
+            async def __call__(self, request):
+                response = await self.get_response(request)
+                response.headers['X-Test-Middleware'] = 'Processed'
+                return response
+
+        handler = ASGIHandler()
+        handler.load_middleware(is_async=True)
+        original_middleware = handler.middleware
+
+        # Add our test middlewares
+        handler.middleware = [UnusedMiddleware, TestMiddleware] + handler.middleware
+
+        scope = {
+            'type': 'http',
+            'method': 'GET',
+            'path': '/',
+        }
+
+        async def receive():
+            return {'type': 'http.request'}
+
+        response_status = None
+        response_headers = None
+
+        async def send(response):
+            nonlocal response_status, response_headers
+            if response['type'] == 'http.response.start':
+                response_status = response['status']
+                response_headers = response['headers']
+
+        await handler(scope, receive, send)
+
+        # Ensure that the TestMiddleware was processed and UnusedMiddleware was skipped
+        self.assertEqual(len(handler.middleware), len(original_middleware) + 1)
+        self.assertIsInstance(handler.middleware[0], TestMiddleware)
+        self.assertEqual(response_status, 200)
+        self.assertIn((b'X-Test-Middleware', b'Processed'), response_headers)
