diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 4648daf3..1d73e219 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1070,13 +1070,20 @@ class Query(BaseExpression):
         return sql, params
 
     def resolve_lookup_value(self, value, can_reuse, allow_joins):
+        """Resolve a lookup value into its final representation."""
         if hasattr(value, 'resolve_expression'):
             value = value.resolve_expression(
                 self, reuse=can_reuse, allow_joins=allow_joins,
             )
         elif isinstance(value, (list, tuple)):
-            # The items of the iterable may be expressions and therefore need
-            # to be resolved independently.
+            # Check if it's a named tuple
+            if hasattr(value, '_fields'):
+                # For named tuples, we need to preserve the type and field names
+                return type(value)(*[
+                    self.resolve_lookup_value(sub_value, can_reuse, allow_joins)
+                    for sub_value in value
+                ])
+            # For regular tuples and lists
             return type(value)(
                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)
                 for sub_value in value
diff --git a/tests/queries/test_query.py b/tests/queries/test_query.py
index 523fa607..8af7c88f 100644
--- a/tests/queries/test_query.py
+++ b/tests/queries/test_query.py
@@ -150,3 +150,41 @@ class TestQuery(SimpleTestCase):
         msg = 'Cannot filter against a non-conditional expression.'
         with self.assertRaisesMessage(TypeError, msg):
             query.build_where(Func(output_field=CharField()))
+
+    def test_named_tuple_range_filter(self):
+        from collections import namedtuple
+        query = Query(Author)
+        Range = namedtuple('Range', ['start', 'end'])
+        value_range = Range(start=2, end=5)
+        where = query.build_where(Q(num__range=value_range))
+        lookup = where.children[0]
+        self.assertIsInstance(lookup, Func)  # Range is translated to a Func expression
+        self.assertEqual(lookup.function, 'BETWEEN')
+        self.assertEqual(len(lookup.source_expressions), 3)  # field, start, end
+        self.assertEqual(lookup.source_expressions[1].value, 2)
+        self.assertEqual(lookup.source_expressions[2].value, 5)
+        self.assertEqual(lookup.source_expressions[0].target, Author._meta.get_field('num'))
+
+    def test_named_tuple_in_complex_query(self):
+        from collections import namedtuple
+        query = Query(Author)
+        Range = namedtuple('Range', ['start', 'end'])
+        value_range1 = Range(start=2, end=5)
+        value_range2 = Range(start=7, end=9)
+        where = query.build_where(Q(num__range=value_range1) | Q(num__range=value_range2))
+        self.assertEqual(where.connector, OR)
+        self.assertEqual(len(where.children), 2)
+        for lookup in where.children:
+            self.assertIsInstance(lookup, Func)
+            self.assertEqual(lookup.function, 'BETWEEN')
+            self.assertEqual(len(lookup.source_expressions), 3)
+            self.assertEqual(lookup.source_expressions[0].target, Author._meta.get_field('num'))
+
+    def test_named_tuple_with_missing_argument(self):
+        from collections import namedtuple
+        query = Query(Author)
+        PartialRange = namedtuple('PartialRange', ['start'])
+        invalid_range = PartialRange(start=2)
+        with self.assertRaises(ValueError):
+            query.build_where(Q(num__range=invalid_range))
+
