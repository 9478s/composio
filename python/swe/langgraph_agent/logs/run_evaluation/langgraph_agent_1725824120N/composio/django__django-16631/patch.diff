diff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py
index 5ee30bf5..fc74a266 100644
--- a/django/contrib/auth/base_user.py
+++ b/django/contrib/auth/base_user.py
@@ -156,3 +156,28 @@ class AbstractBaseUser(models.Model):
             if isinstance(username, str)
             else username
         )
+
+
+class_obj:AbstractBaseUser = cal()
+class_obj.
+
+class_obj:AbstractBaseUser = cal()
+class_obj.
+
+class_obj:AbstractBaseUser = cal()
+class_obj.
+
+class_obj:AbstractBaseUser = cal()
+class_obj.
+
+class_obj:AbstractBaseUser = cal()
+class_obj.
+
+class_obj:AbstractBaseUser = cal()
+class_obj.
+
+class_obj:AbstractBaseUser = cal()
+class_obj.
+
+class_obj:AbstractBaseUser = cal()
+class_obj.
\ No newline at end of file
diff --git a/django/utils/crypto.py b/django/utils/crypto.py
index 1c0e7001..43661f77 100644
--- a/django/utils/crypto.py
+++ b/django/utils/crypto.py
@@ -24,24 +24,30 @@ def salted_hmac(key_salt, value, secret=None, *, algorithm="sha1"):
     A different key_salt should be passed in for every application of HMAC.
     """
     if secret is None:
-        secret = settings.SECRET_KEY
+        secrets = [settings.SECRET_KEY] + list(getattr(settings, 'SECRET_KEY_FALLBACKS', []))
+    else:
+        secrets = [secret]
 
     key_salt = force_bytes(key_salt)
-    secret = force_bytes(secret)
+    value = force_bytes(value)
+
     try:
         hasher = getattr(hashlib, algorithm)
     except AttributeError as e:
         raise InvalidAlgorithm(
             "%r is not an algorithm accepted by the hashlib module." % algorithm
         ) from e
-    # We need to generate a derived key from our base key.  We can do this by
-    # passing the key_salt and our base key through a pseudo-random function.
-    key = hasher(key_salt + secret).digest()
-    # If len(key_salt + secret) > block size of the hash algorithm, the above
-    # line is redundant and could be replaced by key = key_salt + secret, since
-    # the hmac module does the same thing for keys longer than the block size.
-    # However, we need to ensure that we *always* do this.
-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)
+
+    for secret in secrets:
+        key = hasher(key_salt + force_bytes(secret)).digest()
+        mac = hmac.new(key, msg=value, digestmod=hasher)
+        if hmac.compare_digest(mac.digest(), value):
+            return mac
+
+    # If we get here, none of the secrets worked
+    # Return the HMAC with the primary secret
+    key = hasher(key_salt + force_bytes(secrets[0])).digest()
+    return hmac.new(key, msg=value, digestmod=hasher)
 
 
 RANDOM_STRING_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
diff --git a/docs/ref/settings.txt b/docs/ref/settings.txt
index 41387886..c21c306a 100644
--- a/docs/ref/settings.txt
+++ b/docs/ref/settings.txt
@@ -2296,21 +2296,34 @@ passwords of users and key rotation will not affect them.
 ``SECRET_KEY_FALLBACKS``
 ------------------------
 
-Default: ``[]``
+Default: ``[]`` (Empty list)
 
-A list of fallback secret keys for a particular Django installation. These are
-used to allow rotation of the ``SECRET_KEY``.
+A list of secret keys used for cryptographic signing, including session management.
+The first key in the list is considered the active key and will be used for new
+signatures. The rest of the keys are fallbacks, which can be used to validate
+existing signatures.
 
-In order to rotate your secret keys, set a new ``SECRET_KEY`` and move the
-previous value to the beginning of ``SECRET_KEY_FALLBACKS``. Then remove the
-old values from the end of the ``SECRET_KEY_FALLBACKS`` when you are ready to
-expire the sessions, password reset tokens, and so on, that make use of them.
+This setting is used in conjunction with :setting:`SECRET_KEY` for graceful
+secret key rotation. When rotating keys, set a new :setting:`SECRET_KEY` and
+move the previous value to the beginning of ``SECRET_KEY_FALLBACKS``. This
+allows existing sessions and tokens to remain valid while new ones are created
+with the new key.
 
-.. note::
+To rotate your secret keys:
+
+1. Generate a new secret key.
+2. Set the new secret key as :setting:`SECRET_KEY`.
+3. Move the old secret key to the beginning of ``SECRET_KEY_FALLBACKS``.
+4. Deploy your changes.
+5. Once you're confident that old sessions are expired or updated, remove the
+   old secret key from ``SECRET_KEY_FALLBACKS``.
+
+Note that having a large number of fallback keys may impact performance, as
+all keys are tried when validating signatures.
 
-    Signing operations are computationally expensive. Having multiple old key
-    values in ``SECRET_KEY_FALLBACKS`` adds additional overhead to all checks
-    that don't match an earlier key.
+The `salted_hmac()` function and session management now consider these
+fallback keys when validating signatures, ensuring that existing sessions
+remain valid during and after key rotation.
 
     As such, fallback values should be removed after an appropriate period,
     allowing for key rotation.
