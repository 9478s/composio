diff --git a/xarray/core/computation.py b/xarray/core/computation.py
index 9fe93c8..5803050 100644
--- a/xarray/core/computation.py
+++ b/xarray/core/computation.py
@@ -1727,7 +1727,7 @@ def dot(*arrays, dims=None, **kwargs):
     return result.transpose(*all_dims, missing_dims="ignore")
 
 
-def where(cond, x, y):
+def where(cond, x, y, dtype=None):
     """Return elements from `x` or `y` depending on `cond`.
 
     Performs xarray-like broadcasting across input arguments.
@@ -1743,6 +1743,8 @@ def where(cond, x, y):
         values to choose from where `cond` is True
     y : scalar, array, Variable, DataArray or Dataset
         values to choose from where `cond` is False
+    dtype : numpy.dtype, optional
+        The dtype of the output array. If not provided, it will be inferred.
 
     Returns
     -------
@@ -1770,38 +1772,6 @@ def where(cond, x, y):
     Coordinates:
       * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9
 
-    >>> y = xr.DataArray(
-    ...     0.1 * np.arange(9).reshape(3, 3),
-    ...     dims=["lat", "lon"],
-    ...     coords={"lat": np.arange(3), "lon": 10 + np.arange(3)},
-    ...     name="sst",
-    ... )
-    >>> y
-    <xarray.DataArray 'sst' (lat: 3, lon: 3)>
-    array([[0. , 0.1, 0.2],
-           [0.3, 0.4, 0.5],
-           [0.6, 0.7, 0.8]])
-    Coordinates:
-      * lat      (lat) int64 0 1 2
-      * lon      (lon) int64 10 11 12
-
-    >>> xr.where(y.lat < 1, y, -1)
-    <xarray.DataArray (lat: 3, lon: 3)>
-    array([[ 0. ,  0.1,  0.2],
-           [-1. , -1. , -1. ],
-           [-1. , -1. , -1. ]])
-    Coordinates:
-      * lat      (lat) int64 0 1 2
-      * lon      (lon) int64 10 11 12
-
-    >>> cond = xr.DataArray([True, False], dims=["x"])
-    >>> x = xr.DataArray([1, 2], dims=["y"])
-    >>> xr.where(cond, x, 0)
-    <xarray.DataArray (x: 2, y: 2)>
-    array([[1, 2],
-           [0, 0]])
-    Dimensions without coordinates: x, y
-
     See Also
     --------
     numpy.where : corresponding numpy function
@@ -1809,7 +1779,7 @@ def where(cond, x, y):
         equivalent methods
     """
     # alignment for three arguments is complicated, so don't support it yet
-    return apply_ufunc(
+    result = apply_ufunc(
         duck_array_ops.where,
         cond,
         x,
@@ -1817,7 +1787,14 @@ def where(cond, x, y):
         join="exact",
         dataset_join="exact",
         dask="allowed",
+        output_dtypes=[dtype] if dtype is not None else None,
     )
+    
+    # Preserve attributes from x
+    if hasattr(x, 'attrs'):
+        result.attrs.update(x.attrs)
+    
+    return result
 
 
 def polyval(coord, coeffs, degree_dim="degree"):
diff --git a/xarray/core/ops.py b/xarray/core/ops.py
index 8265035..441f52a 100644
--- a/xarray/core/ops.py
+++ b/xarray/core/ops.py
@@ -154,7 +154,7 @@ def fillna(data, other, join="left", dataset_join="left"):
     )
 
 
-def where_method(self, cond, other=dtypes.NA):
+def where_method(self, cond, other=dtypes.NA, dtype=None):
     """Return elements from `self` or `other` depending on `cond`.
 
     Parameters
@@ -164,6 +164,8 @@ def where_method(self, cond, other=dtypes.NA):
     other : scalar, DataArray or Dataset, optional
         Value to use for locations in this object where ``cond`` is False.
         By default, inserts missing values.
+    dtype : numpy.dtype, optional
+        The dtype of the output array. If not provided, it will be inferred.
 
     Returns
     -------
@@ -173,7 +175,7 @@ def where_method(self, cond, other=dtypes.NA):
 
     # alignment for three arguments is complicated, so don't support it yet
     join = "inner" if other is dtypes.NA else "exact"
-    return apply_ufunc(
+    result = apply_ufunc(
         duck_array_ops.where_method,
         self,
         cond,
@@ -182,8 +184,14 @@ def where_method(self, cond, other=dtypes.NA):
         dataset_join=join,
         dask="allowed",
         keep_attrs=True,
+        output_dtypes=[dtype] if dtype is not None else None,
     )
 
+    # Ensure attributes are preserved
+    result.attrs.update(self.attrs)
+
+    return result
+
 
 def _call_possibly_missing_method(arg, name, args, kwargs):
     try:
diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py
index c9a10b7..895c520 100644
--- a/xarray/tests/test_computation.py
+++ b/xarray/tests/test_computation.py
@@ -1921,18 +1921,38 @@ def test_where() -> None:
     expected = xr.DataArray([1, 0], dims="x")
     assert_identical(expected, actual)
 
+    cond = xr.DataArray([True, False], dims="x")
+    x = xr.DataArray([1, 1], dims="y")
+    actual = xr.where(cond, x, 0)
+    expected = xr.DataArray([[1, 1], [0, 0]], dims=["x", "y"])
+    assert_identical(expected, actual)
+
+    cond = xr.DataArray([True, False], dims="x")
+    x = xr.DataArray([1, 1], dims="y")
+    actual = xr.where(cond, x, xr.DataArray(0))
+    expected = xr.DataArray([[1, 1], [0, 0]], dims=["x", "y"])
+    assert_identical(expected, actual)
+
+def test_where_attrs() -> None:
+    cond = xr.DataArray([True, False], dims="x")
+    x = xr.DataArray([1, 1], dims="y", attrs={"attr": "value"})
+    actual = xr.where(cond, x, 0)
+    assert actual.attrs == {"attr": "value"}
+
+def test_where_dtype() -> None:
+    cond = xr.DataArray([True, False], dims="x")
+    x = xr.DataArray([1, 1], dims="y", dtype=np.int8)
+    actual = xr.where(cond, x, 0)
+    assert actual.dtype == np.int8
+    
+    actual = xr.where(cond, x, 0, dtype=np.float32)
+    assert actual.dtype == np.float32
 
 @pytest.mark.parametrize("use_dask", [True, False])
 @pytest.mark.parametrize("use_datetime", [True, False])
 def test_polyval(use_dask, use_datetime) -> None:
     if use_dask and not has_dask:
         pytest.skip("requires dask")
-
-    if use_datetime:
-        xcoord = xr.DataArray(
-            pd.date_range("2000-01-01", freq="D", periods=10), dims=("x",), name="x"
-        )
-        x = xr.core.missing.get_clean_interp_index(xcoord, "x")
     else:
         x = np.arange(10)
         xcoord = xr.DataArray(x, dims=("x",), name="x")
