diff --git a/CHANGELOG.rst b/CHANGELOG.rst
index 3f96372..6a06d21 100644
--- a/CHANGELOG.rst
+++ b/CHANGELOG.rst
@@ -1,3 +1,13 @@
+Changelog
+=========
+
+Improvements
+------------
+
+* Improved handling of chained exceptions in distributed testing scenarios, ensuring that the full exception chain is properly serialized and displayed when using pytest-xdist.
+
+.. _release-7.4.0:
+
 =========
 Changelog
 =========
diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py
index a0f4d15..b9feb4f 100644
--- a/src/_pytest/_code/code.py
+++ b/src/_pytest/_code/code.py
@@ -1084,3 +1084,20 @@ def filter_traceback(entry):
     return (
         not p.relto(_PLUGGY_DIR) and not p.relto(_PYTEST_DIR) and not p.relto(_PY_DIR)
     )
+
+class ReprTraceback:
+    @classmethod
+    def from_str(cls, s):
+        lines = s.splitlines()
+        entries = []
+        for line in lines:
+            if line.startswith("  "):
+                entries.append(ReprEntryNative(line))
+            else:
+                entries.append(ReprEntry(line))
+        return cls(entries)
+
+    def toterminal(self, tw, **kwargs):
+        for entry in self.reprentries:
+            entry.toterminal(tw)
+        return tw.stringio.getvalue() if kwargs.get("stringio") else None
diff --git a/src/_pytest/reports.py b/src/_pytest/reports.py
index 4682d5b..2951eaf 100644
--- a/src/_pytest/reports.py
+++ b/src/_pytest/reports.py
@@ -99,11 +99,56 @@ class BaseReport:
         return "".join(
             content for (prefix, content) in self.get_sections("Captured stderr")
         )
+class TestReport(BaseReport):
+    __test__ = False  # disable this class from collection by pytest
+
+    @classmethod
+    def from_item_and_call(cls, item, call):
+        keywords = {x: 1 for x in item.keywords}
+        keywords.update(item.extra_keyword_matches)
+
+        if call.excinfo is not None:
+            longrepr = item.repr_failure(call.excinfo)
+            if isinstance(longrepr, ExceptionInfo):
+                longrepr = longrepr.getrepr(
+                    funcargs=True,
+                    showlocals=item.config.getoption("showlocals", False),
+                    tbfilter=item.config.getoption("tbfilter", True),
+                    chain=True,  # Always include chained exceptions
+                )
+        else:
+            longrepr = None
+
+        return cls(
+            nodeid=item.nodeid,
+            location=item.location,
+            keywords=keywords,
+            outcome=call.outcome,
+            longrepr=longrepr,
+            when=call.when,
+            sections=call.sections,
+            duration=call.duration,
+            user_properties=item.user_properties,
+        )
+
+    def _to_json(self):
+        data = super()._to_json()
+        if isinstance(self.longrepr, ReprExceptionInfo):
+            data['longrepr'] = self.longrepr.reprtraceback.toterminal(stringio=True)
+        return data
+
+    @classmethod
+    def _from_json(cls, reportdict):
+        report = super()._from_json(reportdict)
+        if isinstance(report.longrepr, str):
+            from _pytest._code.code import ReprExceptionInfo, ReprTraceback
+            reprtraceback = ReprTraceback.from_str(report.longrepr)
+            report.longrepr = ReprExceptionInfo(reprtraceback, None)
+        return report
 
     passed = property(lambda x: x.outcome == "passed")
     failed = property(lambda x: x.outcome == "failed")
     skipped = property(lambda x: x.outcome == "skipped")
-
     @property
     def fspath(self):
         return self.nodeid.split("::")[0]
diff --git a/testing/test_reports.py b/testing/test_reports.py
index b8b1a54..d39afb3 100644
--- a/testing/test_reports.py
+++ b/testing/test_reports.py
@@ -311,3 +311,112 @@ class TestHooks:
             _ = pytestconfig.hook.pytest_report_from_serializable(
                 config=pytestconfig, data=data
             )
+
+def test_chained_exceptions(testdir):
+    testdir.makepyfile(
+        """
+        def test_chained_exception():
+            try:
+                try:
+                    raise ValueError("inner")
+                except ValueError as e:
+                    raise RuntimeError("outer") from e
+            except RuntimeError as e:
+                raise AssertionError("test") from e
+        """
+    )
+    result = testdir.runpytest("-vv")
+    result.stdout.fnmatch_lines([
+        "*ValueError: inner",
+        "*RuntimeError: outer",
+        "*AssertionError: test",
+    ])
+    result.assert_outcomes(failed=1)
+
+def test_chained_exceptions_xdist(testdir):
+    testdir.makepyfile(
+        """
+        def test_chained_exception():
+            try:
+                try:
+                    raise ValueError("inner")
+                except ValueError as e:
+                    raise RuntimeError("outer") from e
+            except RuntimeError as e:
+                raise AssertionError("test") from e
+        """
+    )
+    result = testdir.runpytest("-vv", "-n", "2")
+    result.stdout.fnmatch_lines([
+        "*ValueError: inner",
+        "*RuntimeError: outer",
+        "*AssertionError: test",
+    ])
+    result.assert_outcomes(failed=1)
+
+def run_pytest_with_xdist(testdir, *args):
+    pytest_ini = testdir.makeini(
+        """
+        [pytest]
+        console_output_style = classic
+        """
+    )
+    result = testdir.runpytest(*args)
+    return result
+
+def test_chained_exceptions_xdist_output(testdir):
+    testdir.makepyfile(
+        """
+        def test_chained_exception():
+            try:
+                try:
+                    raise ValueError("inner")
+                except ValueError as e:
+                    raise RuntimeError("outer") from e
+            except RuntimeError as e:
+                raise AssertionError("test") from e
+        """
+    )
+    result = run_pytest_with_xdist(testdir, "-vv", "-n", "2")
+    result.stdout.fnmatch_lines([
+        "*ValueError: inner",
+        "*RuntimeError: outer",
+        "*AssertionError: test",
+    ])
+    result.assert_outcomes(failed=1)
+
+def test_chained_exceptions_xdist_serialization(testdir):
+    testdir.makepyfile(
+        """
+        def test_chained_exception():
+            try:
+                try:
+                    raise ValueError("inner")
+                except ValueError as e:
+                    raise RuntimeError("outer") from e
+            except RuntimeError as e:
+                raise AssertionError("test") from e
+        """
+    )
+    result = testdir.runpytest_subprocess("-vv", "-n", "2")
+    result.stdout.fnmatch_lines([
+        "*ValueError: inner",
+        "*RuntimeError: outer",
+        "*AssertionError: test",
+    ])
+    result.assert_outcomes(failed=1)
+
+    # Check if the exception chain is properly serialized
+    reports = result.get_serialized_reports()
+    assert len(reports) > 0
+    
+    for report in reports:
+        if report["when"] == "call" and report["outcome"] == "failed":
+            longrepr = report["longrepr"]
+            assert isinstance(longrepr, str)
+            assert "ValueError: inner" in longrepr
+            assert "RuntimeError: outer" in longrepr
+            assert "AssertionError: test" in longrepr
+            break
+    else:
+        pytest.fail("Failed test report not found in serialized reports")
