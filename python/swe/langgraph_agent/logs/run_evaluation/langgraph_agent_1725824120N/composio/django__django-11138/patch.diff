diff --git a/django/db/backends/mysql/base.py b/django/db/backends/mysql/base.py
index 2cd6248c..d9423212 100644
--- a/django/db/backends/mysql/base.py
+++ b/django/db/backends/mysql/base.py
@@ -98,6 +98,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):
     display_name = 'MySQL'
     # This dictionary maps Field objects to their associated MySQL column
     # types, as strings. Column-type strings can contain format strings; they'll
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self._set_autocommit(False)
+        self.timezone_name = self.settings_dict.get('TIME_ZONE') or 'UTC'
     # be interpolated against the values of Field.__dict__ before being output.
     # If a column type is set to None, it won't be included in the output.
     data_types = {
diff --git a/django/db/backends/mysql/operations.py b/django/db/backends/mysql/operations.py
index 50f85e06..e7f9c2fc 100644
--- a/django/db/backends/mysql/operations.py
+++ b/django/db/backends/mysql/operations.py
@@ -70,7 +70,9 @@ class DatabaseOperations(BaseDatabaseOperations):
 
     def _convert_field_to_tz(self, field_name, tzname):
         if settings.USE_TZ:
-            field_name = "CONVERT_TZ(%s, 'UTC', '%s')" % (field_name, tzname)
+            db_timezone = self.connection.settings_dict.get('TIME_ZONE', 'UTC')
+            if db_timezone != tzname:
+                field_name = "CONVERT_TZ(%s, '%s', '%s')" % (field_name, db_timezone, tzname)
         return field_name
 
     def datetime_cast_date_sql(self, field_name, tzname):
diff --git a/docs/ref/databases.txt b/docs/ref/databases.txt
index 45120cbd..c1c84d2d 100644
--- a/docs/ref/databases.txt
+++ b/docs/ref/databases.txt
@@ -87,6 +87,135 @@ result in unexpected behavior such as "value too long" errors from your
 database for data that is valid in Django. See the database specific notes
 below for information on how to set up your database correctly.
 
+Time zones
+----------
+
+When :setting:`USE_TZ` is ``True``, Django uses time zone-aware datetime objects.
+However, certain databases (including MySQL, SQLite, and Oracle) don't support
+native time zone handling.
+
+For these databases, Django now respects the :setting:`TIME_ZONE` setting in the
+database configuration. This setting determines the time zone in which datetimes
+are stored. When a datetime is retrieved from the database, Django converts it
+to the time zone specified by the :setting:`TIME_ZONE` setting of the Django project.
+
+It's crucial to set the :setting:`TIME_ZONE` in your database configuration to match
+the time zone in which your database stores datetimes. This ensures correct
+handling of datetimes across your application.
+
+For MySQL specifically:
+
+1. In your Django settings, add a :setting:`TIME_ZONE` to your database configuration:
+
+   .. code-block:: python
+
+       DATABASES = {
+           'default': {
+               ...
+               'TIME_ZONE': 'Europe/London',  # Replace with your database's timezone
+           }
+       }
+
+2. Make sure your MySQL server is configured to use the same timezone. You can set
+   this in your MySQL configuration file (usually `my.cnf` or `my.ini`):
+
+   .. code-block:: ini
+
+       [mysqld]
+       default-time-zone = 'Europe/London'
+
+   Or you can set it at runtime with:
+
+   .. code-block:: sql
+
+       SET GLOBAL time_zone = 'Europe/London';
+
+3. Ensure that your MySQL installation has the necessary timezone tables. You can
+   populate these tables using the `mysql_tzinfo_to_sql` program:
+
+   .. code-block:: bash
+
+       mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root mysql
+
+By following these steps, you ensure that Django and MySQL are in sync regarding
+timezone handling, preventing any discrepancies in datetime values.
+
+For SQLite:
+
+SQLite doesn't have native timezone support, so Django needs to handle timezone conversions in Python. Here's how to set it up:
+
+1. In your Django settings, add a :setting:`TIME_ZONE` to your database configuration:
+
+   .. code-block:: python
+
+       DATABASES = {
+           'default': {
+               'ENGINE': 'django.db.backends.sqlite3',
+               'NAME': BASE_DIR / 'db.sqlite3',
+               'TIME_ZONE': 'Europe/London',  # Replace with your desired timezone
+           }
+       }
+
+2. Make sure your application code is consistent in its use of timezones. When creating datetime objects, always use timezone-aware datetimes:
+
+   .. code-block:: python
+
+       from django.utils import timezone
+
+       current_time = timezone.now()
+
+3. When retrieving datetime values from the database, Django will automatically convert them to the timezone specified in your project's :setting:`TIME_ZONE` setting.
+
+For Oracle:
+
+Oracle has its own timezone handling, which Django can leverage. Here's how to set it up:
+
+1. In your Django settings, add a :setting:`TIME_ZONE` to your database configuration:
+
+   .. code-block:: python
+
+       DATABASES = {
+           'default': {
+               'ENGINE': 'django.db.backends.oracle',
+               'NAME': 'xe',
+               'USER': 'a_user',
+               'PASSWORD': 'a_password',
+               'HOST': '',
+               'PORT': '',
+               'TIME_ZONE': 'Europe/London',  # Replace with your database's timezone
+           }
+       }
+
+2. Ensure your Oracle database is configured to use the same timezone. You can set this at the system level or the session level:
+
+   .. code-block:: sql
+
+       ALTER SESSION SET TIME_ZONE = 'Europe/London';
+
+3. Make sure your Oracle installation has the necessary timezone files. These are usually part of the Oracle installation, but if you encounter issues, you may need to update them:
+
+   .. code-block:: sql
+
+       BEGIN
+         DBMS_DST.CREATE_TRIGGERED_TRANSITION_TABLE;
+         DBMS_DST.BEGIN_PREPARE(2000, 2037);
+         DBMS_DST.PREPARE_TRANSITION_TABLE('AMERICA/NEW_YORK');
+         DBMS_DST.END_PREPARE;
+       END;
+       /
+
+   Replace 'AMERICA/NEW_YORK' with the timezone you're using.
+
+By following these steps for SQLite and Oracle, you ensure that Django and your database are in sync regarding timezone handling, preventing any discrepancies in datetime values.
+
+Remember, when :setting:`USE_TZ` is ``True``, Django will store datetimes in UTC in the database and convert them to the appropriate timezone when retrieving them. The :setting:`TIME_ZONE` in your database configuration tells Django what timezone the database is using, allowing for correct conversions.
+
+If you're using MySQL, SQLite, or Oracle, make sure to set the :setting:`TIME_ZONE`
+in your database configuration to match the time zone in which your database
+stores datetimes. This ensures correct handling of datetimes across your application.
+
+.. _postgresql-notes:
+
 .. _postgresql-notes:
 
 PostgreSQL notes
diff --git a/docs/releases/3.0.txt b/docs/releases/3.0.txt
index 11257b70..cfc5fa7c 100644
--- a/docs/releases/3.0.txt
+++ b/docs/releases/3.0.txt
@@ -41,6 +41,18 @@ What's new in Django 3.0
 Minor features
 --------------
 
+:mod:`django.db.backends`
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+* Improved timezone support for MySQL, SQLite, and Oracle databases. Django now
+  respects the :setting:`TIME_ZONE` setting in database configurations for these
+  backends, ensuring correct handling of datetimes across different timezones.
+  This change affects how datetimes are stored and retrieved from the database,
+  providing more consistent behavior across different database backends.
+
+:mod:`django.contrib.admin`
+--------------
+
 :mod:`django.contrib.admin`
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
