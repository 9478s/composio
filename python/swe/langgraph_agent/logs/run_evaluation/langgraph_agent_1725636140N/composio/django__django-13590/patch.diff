diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 4648daf3..b3726d69 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1077,10 +1077,13 @@ class Query(BaseExpression):
         elif isinstance(value, (list, tuple)):
             # The items of the iterable may be expressions and therefore need
             # to be resolved independently.
-            return type(value)(
+            resolved_values = [
                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)
                 for sub_value in value
-            )
+            ]
+            if isinstance(value, tuple) and hasattr(value, '_fields'):  # Check if it's a named tuple
+                return type(value)(*resolved_values)  # Reconstruct the named tuple
+            return type(value)(resolved_values)
         return value
 
     def solve_lookup_type(self, lookup):
diff --git a/docs/releases/3.1.txt b/docs/releases/3.1.txt
index 730d0b68..628f663b 100644
--- a/docs/releases/3.1.txt
+++ b/docs/releases/3.1.txt
@@ -853,4 +853,7 @@ to remove usage of these features.
   first positional argument.
 
 * Support for ``SimpleTestCase.allow_database_queries`` and
+* Fixed a bug in Django 3.0 where using named tuples as arguments to `__range`
+  lookups would raise a `TypeError`. This issue affected the use of named
+  tuples in range queries for models.
   ``TransactionTestCase.multi_db`` is removed.
diff --git a/tests/queries/tests.py b/tests/queries/tests.py
index 5b667186..6644e5ab 100644
--- a/tests/queries/tests.py
+++ b/tests/queries/tests.py
@@ -97,6 +97,31 @@ class Queries1Tests(TestCase):
         self.assertEqual(qs4.query.subq_aliases, {'T', 'U', 'V'})
         # It is possible to reuse U for the second subquery, no need to use W.
         self.assertNotIn('w0', str(qs4.query).lower())
+    def test_range_query_with_named_tuple(self):
+        from collections import namedtuple
+        Range = namedtuple('Range', ['start', 'end'])
+        range_tuple = Range(start=2002, end=3003)
+        
+        # This query should now work without raising a TypeError
+        result = Author.objects.filter(num__range=range_tuple)
+        
+        self.assertEqual(result.count(), 2)
+        self.assertCountEqual(
+            [author.name for author in result],
+            ['a2', 'a3']
+        )
+
+    def test_subquery_condition(self):
+        qs1 = Tag.objects.filter(pk__lte=0)
+        qs2 = Tag.objects.filter(parent__in=qs1)
+        qs3 = Tag.objects.filter(parent__in=qs2)
+        self.assertEqual(qs3.query.subq_aliases, {'T', 'U', 'V'})
+        self.assertIn('v0', str(qs3.query).lower())
+        qs4 = qs3.filter(parent__in=qs1)
+        self.assertEqual(qs4.query.subq_aliases, {'T', 'U', 'V'})
+        # It is possible to reuse U for the second subquery, no need to use W.
+        self.assertNotIn('w0', str(qs4.query).lower())
+        # So, 'U0.\"id\"' is referenced in SELECT and WHERE twice.
         # So, 'U0."id"' is referenced in SELECT and WHERE twice.
         self.assertEqual(str(qs4.query).lower().count('u0.'), 4)
 
